{"version":3,"sources":["spriteFinder.js","index.js"],"names":["src_spriteFinder","spriteFinder","Context","Canvas","backgroundCol","pixelArr","module","pixelInBoxes","x","y","boxes","index","box","width","height","exploreSpriteBox","newBox","boxBoundaries","boxMeetBoundaries","neighbourCol","neighboursBackCol","boxCanExpand","i","expandBox","contractBox","left","getImageData","data","right","top","bottom","edgeAllBackgroundCol","edge","length","pixel","pixelsEqual","edgeColors","edgeBoundaries","direction","setCanvas","canvas","context","imageData","push","setPixelArr","comparePixels","pixelA","pixelB","Math","pow","getPixelArr","setBackgroundCol","max_count","curr_count","sortedArr","sort","console","log","getBackgroundCol","getCanvas","findBoxes","document","getElementById","addEventListener","e","reader","FileReader","onload","event","img","Image","src","target","result","ctx","drawImage","boxJSON","JSON","stringify","sprite","spriteData","putImageData","scssDisplay","innerText","url","spriteMap","boxnum","makeSCSS","readAsDataURL","files","getContext","ReactDOM","render","react_default","a","createElement","react_router_dom","basename","process"],"mappings":"oIAAA,IA6PeA,EAAA,CAACC,aA7PI,WAChB,IAAIC,EAEAC,EAGAC,EAFAC,EAAW,GAGXC,EAAS,GA0Hb,SAASC,EAAaC,EAAGC,EAAGC,GACxB,IAAK,IAAIC,KAASD,EAAM,CACpB,IAAIE,EAAMF,EAAMC,GAChB,GAAIH,GAAKI,EAAIJ,GAAKA,GAAMI,EAAIJ,EAAII,EAAIC,OAC5BJ,GAAKG,EAAIH,GAAKA,GAAMG,EAAIH,EAAIG,EAAIE,OAChC,OAAOF,EAInB,OAAO,KAKX,SAASG,EAAiBP,EAAGC,GAIzB,IAHA,IAAIG,EApBR,SAAgBJ,EAAGC,EAAGI,EAAOC,GACzB,MAAO,CAACN,EAAGA,EAAGC,EAAGA,EAAGI,MAAOA,EAAOC,OAAQA,GAmBhCE,CAAOR,EAAGC,EAAG,EAAG,GACtBQ,EAAgBC,EAAkBN,GAClCO,EAAeC,EAAkBR,GAC9BS,EAAaJ,EAAeE,IAAc,CAI7C,IAAK,IAAIG,EAAE,EAAGA,EAAE,EAAGA,IACVH,EAAaG,IAAOL,EAAcK,IACnCC,EAAUX,EAAKU,GAGvBL,EAAgBC,EAAkBN,GAClCO,EAAeC,EAAkBR,GAIrC,OAgFJ,SAAqBA,GACbA,EAAIC,MAAQ,IACZD,EAAIC,OAAS,GAEbD,EAAIE,OAAS,IACbF,EAAIE,QAAU,GAtFlBU,CAAYZ,GACLA,EAKX,SAASM,EAAkBN,GACvB,MAAO,CACO,IAAVA,EAAIJ,EACJI,EAAIJ,EAAII,EAAIC,QAAUV,EAAOU,MACnB,IAAVD,EAAIH,EACJG,EAAIH,EAAIG,EAAIE,SAAWX,EAAOW,QAOtC,SAASM,EAAkBR,GACvB,IAAIa,EAAOvB,EAAQwB,aAAad,EAAIJ,EAAE,EAAGI,EAAIH,EAAG,EAAGG,EAAIE,QAAQa,KAC3DC,EAAQ1B,EAAQwB,aAAad,EAAIJ,EAAII,EAAIC,MAAQ,EAAGD,EAAIH,EAAG,EAAGG,EAAIE,QAAQa,KAC1EE,EAAM3B,EAAQwB,aAAad,EAAIJ,EAAGI,EAAIH,EAAE,EAAGG,EAAIC,MAAO,GAAGc,KACzDG,EAAS5B,EAAQwB,aAAad,EAAIJ,EAAGI,EAAIH,EAAIG,EAAIE,OAAS,EAAGF,EAAIC,MAAO,GAAGc,KAE/E,MAAO,CACHI,EAAqBN,GACrBM,EAAqBH,GACrBG,EAAqBF,GACrBE,EAAqBD,IAI7B,SAASC,EAAqBC,GAG1B,IAAK,IAAIV,EAAE,EAAGA,EAAEU,EAAKC,OAAQX,GAAG,EAAE,CAC9B,IAAIY,EAAQ,CAACF,EAAKV,GAAIU,EAAKV,EAAE,GAAIU,EAAKV,EAAE,GAAIU,EAAKV,EAAE,IACnD,IAAKhB,EAAO6B,YAAYD,EAAO9B,GAC3B,OAAO,EAGf,OAAO,EAIX,SAASiB,EAAae,EAAYC,GAC9B,IAAK,IAAIf,EAAE,EAAGA,EAAE,EAAGA,IACf,IAAKc,EAAWd,KAAOe,EAAef,GAClC,OAAO,EAGf,OAAO,EAKX,SAASC,EAAUX,EAAK0B,GACpB,OAAQA,GACJ,KAAK,EACF1B,EAAIJ,GAAK,EACTI,EAAIC,OAAS,EACb,MACH,KAAK,EACFD,EAAIC,OAAS,EACb,MACH,KAAK,EACFD,EAAIH,GAAK,EACTG,EAAIE,QAAU,EACd,MACH,KAAK,EACFF,EAAIE,QAAU,GAoBzB,OA1OAR,EAAOiC,UAAY,SAASC,EAAQC,EAASC,GACzCvC,EAASqC,EACTtC,EAAUuC,EACEC,EAVhB,SAAqBf,GACjB,IAAK,IAAIL,EAAE,EAAGA,EAAEK,EAAKM,OAAQX,GAAG,EAAE,CAC9B,IAAIY,EAAQ,CAACP,EAAKL,GAAIK,EAAKL,EAAE,GAAIK,EAAKL,EAAE,GAAIK,EAAKL,EAAE,IACnDjB,EAASsC,KAAKT,IASlBU,CADOF,EAAUf,OAIrBrB,EAAOuC,cAAgB,SAASC,EAAQC,GAIpC,OAFgBD,EAAO,GAAPE,KAAAC,IAAY,IAAO,GAAIH,EAAO,GAAPE,KAAAC,IAAY,IAAO,GAAgB,IAAZH,EAAO,GAAWA,EAAO,IACvEC,EAAO,GAAPC,KAAAC,IAAY,IAAO,GAAIF,EAAO,GAAPC,KAAAC,IAAY,IAAO,GAAgB,IAAZF,EAAO,GAAWA,EAAO,KAI3FzC,EAAO6B,YAAc,SAASW,EAAQC,GAClC,GAAkB,IAAdD,EAAO,IAA0B,IAAdC,EAAO,GAC1B,OAAO,EAEX,IAAK,IAAIzB,EAAE,EAAGA,EAAE,EAAGA,IACf,GAAIwB,EAAOxB,KAAOyB,EAAOzB,GACrB,OAAO,EAGf,OAAO,GAGXhB,EAAO4C,YAAc,WACjB,OAAO7C,GAIXC,EAAO6C,iBAAmB,WAOtB,IANA,IAEIjB,EAFAkB,EAAY,EACZC,EAAa,EAEbC,EAAYjD,EAASkD,KAAK,SAAST,EAAQC,GAC3C,OAAOzC,EAAOuC,cAAcC,EAAQC,KAE/BzB,EAAE,EAAGA,EAAEgC,EAAUrB,OAAQX,IAC1BhB,EAAO6B,YAAYmB,EAAUhC,GAAIgC,EAAUhC,EAAE,IAC7C+B,GAAc,GAGVA,EAAaD,IACbA,EAAYC,EACZnB,EAAQoB,EAAUhC,EAAE,IAExB+B,EAAa,GAGjBA,EAAaD,IACbA,EAAYC,EACZnB,EAAQoB,EAAUA,EAAUrB,OAAO,IAEvCuB,QAAQC,IAAIvB,GACZ9B,EAAgB8B,GAGpB5B,EAAOoD,iBAAmB,WACtB,OAAOtD,GAGXE,EAAOqD,UAAY,WACf,OAAOxD,GAGXG,EAAOsD,UAAY,WASf,IARA,IAAIlD,EAAQ,GACR8B,EAASlC,EAAOqD,YAChB7C,EAAS0B,EAAO1B,OAChBD,EAAQ2B,EAAO3B,MAIfJ,EAAI,EACDA,EAAIK,GAAO,CAEd,IADA,IAAIN,EAAI,EACDA,EAAIK,GAAM,CACb,IAAIqB,EAAQhC,EAAQwB,aAAalB,EAAGC,EAAG,EAAG,GAAGkB,KAE7C,GAAIrB,EAAO6B,YAAYD,EAAO9B,GAC1BI,GAAK,MADT,CAIA,IAAII,EAAML,EAAaC,EAAGC,EAAGC,GACjB,OAARE,GAMAA,EAAMG,EAAiBP,EAAGC,GAC1BC,EAAMiC,KAAK/B,GACXJ,GAAK,GANLA,GAAKI,EAAIC,OASjBJ,GAAK,EAOT,OAAOC,GAkIJJ,EA1PS,4CCKFuD,SAASC,eAAe,eAC1BC,iBAAiB,SAKjC,SAAqBC,GACjB,IAAIC,EAAS,IAAIC,WACjBD,EAAOE,OAAS,SAASC,GACrB,IAAIC,EAAM,IAAIC,MACdD,EAAIE,IAAMH,EAAMI,OAAOC,OACvBJ,EAAIF,OAAS,WACT3B,EAAO3B,MAAQwD,EAAIxD,MACnB2B,EAAO1B,OAASuD,EAAIvD,OACpB4D,EAAIC,UAAUN,EAAI,EAAE,GACpB,IAAI3B,EAAYgC,EAAIhD,aAAa,EAAG,EAAGc,EAAO3B,MAAO2B,EAAO1B,QACjD4B,EAAUf,KACrB1B,EAAasC,UAAUC,EAAQkC,EAAKhC,GAEpCzC,EAAakD,mBAEb,IAAIzC,EAAQT,EAAa2D,YAC5BgB,EAAUC,KAAKC,UAAUpE,GAGtB,IAAK,IAAIC,KAFT6C,QAAQC,IAAImB,GAEMlE,EAAM,CAIvB,IAHA,IAAIE,EAAMF,EAAMC,GACZoE,EAASL,EAAIhD,aAAad,EAAIJ,EAAGI,EAAIH,EAAGG,EAAIC,MAAOD,EAAIE,QACvDkE,EAAaD,EAAOpD,KACfL,EAAE,EAAGA,EAAE0D,EAAW/C,OAAQX,GAAG,EACrC0D,EAAW1D,GAAK,IAAM0D,EAAW1D,GACjC0D,EAAW1D,EAAE,GAAK,IAAM0D,EAAW1D,EAAE,GACrC0D,EAAW1D,EAAE,GAAK,IAAM0D,EAAW1D,EAAE,GAEtCoD,EAAIO,aAAaF,EAAQnE,EAAIJ,EAAGI,EAAIH,GAGrCyE,EAAYC,UA2BxB,SAAkBzE,EAAO0E,GACxB,IAQIC,EAAY,mBAEhB,IAAK,IAAIC,KAAU5E,EAAM,CACxB,IAAIE,EAAMF,EAAM4E,GAGZP,EAAS,SAAWO,EAAS,OAAS1E,EAAIJ,EAC5C,QAAUI,EAAIH,EAAI,OAASG,EAAIC,MAAQ,OAASD,EAAIE,OAAS,MAC/DuE,GAAwBN,EACpBO,IAAW5E,EAAMuB,SACpBoD,GAAwB,QAMvB,MAxBS,+JAsBZA,GAAwB,SAlDWE,CAAS7E,EAAO2D,EAAIE,OAIpDN,EAAOuB,cAAcxB,EAAEQ,OAAOiB,MAAM,MAxCgB,GACxD,IAAIjD,EAASqB,SAASC,eAAe,eACjCY,EAAMlC,EAAOkD,WAAW,MACxBR,EAAcrB,SAASC,eAAe,iBAwF1C6B,IAASC,OAAOC,EAAAC,EAAAC,cAACC,EAAA,EAAD,CAAQC,SAAUC,mBAAmCrC,SAASC,eAAe","file":"static/js/main.734b969e.chunk.js","sourcesContent":["var spriteFinder = (function(){\n    let Context;\n    let ImageData;\n    let Canvas;\n    let pixelArr = [];\n    let Data;\n    let backgroundCol;\n    var module = {};\n\n    function setPixelArr(data){\n        for (let i=0; i<data.length; i+=4){\n            let pixel = [data[i], data[i+1], data[i+2], data[i+3]];\n            pixelArr.push(pixel);\n        }\n    }\n\n    module.setCanvas = function(canvas, context, imageData){\n        Canvas = canvas;\n        Context = context;\n        ImageData = imageData;\n        Data = imageData.data;\n        setPixelArr(Data);\n    }\n\n    module.comparePixels = function(pixelA, pixelB){\n        // change the pixel vals to an integer, r + g + b + a occupying different digits\n        let pixelAVal = pixelA[0] * 100 ** 3 + pixelA[1] * 100 ** 2 + pixelA[2] * 100 + pixelA[3];\n        let pixelBVal = pixelB[0] * 100 ** 3 + pixelB[1] * 100 ** 2 + pixelB[2] * 100 + pixelB[3];\n        return pixelAVal - pixelBVal;\n    }\n\n    module.pixelsEqual = function(pixelA, pixelB){\n        if (pixelA[3] === 0 && pixelB[3] === 0){\n            return true;\n        }\n        for (let i=0; i<4; i++){\n            if (pixelA[i] !== pixelB[i]){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    module.getPixelArr = function(){\n        return pixelArr;\n    }\n\n    // find most common color in spritesheet. This is the background color.\n    module.setBackgroundCol = function(){\n        let max_count = 1;\n        let curr_count = 1;\n        let pixel;\n        let sortedArr = pixelArr.sort(function(pixelA, pixelB){\n            return module.comparePixels(pixelA, pixelB);\n        });\n        for (let i=1; i<sortedArr.length; i++){\n            if (module.pixelsEqual(sortedArr[i], sortedArr[i-1])){\n                curr_count += 1;\n            }\n            else {\n                if (curr_count > max_count){\n                    max_count = curr_count;\n                    pixel = sortedArr[i-1];\n                }\n                curr_count = 1;\n            }\n        }\n        if (curr_count > max_count){\n            max_count = curr_count\n            pixel = sortedArr[sortedArr.length-1]\n        }\n        console.log(pixel);\n        backgroundCol = pixel;\n    }\n\n    module.getBackgroundCol = function(){\n        return backgroundCol;\n    }\n    \n    module.getCanvas = function(){\n        return Canvas;\n    }\n\n    module.findBoxes = function(){\n        let boxes = [];\n        let canvas = module.getCanvas();\n        let height = canvas.height;\n        let width = canvas.width;\n        // scan over each line of the image, walking from left to right, until you\n        // find a pixel that's not of backgroundCol\n         \n        let y = 0;\n        while (y < height){\n            let x = 0;\n            while (x < width){\n                let pixel = Context.getImageData(x, y, 1, 1).data;\n                // check to see if pixelCol is the same as backgroundCol\n                if (module.pixelsEqual(pixel, backgroundCol)){\n                    x += 1;\n                    continue;\n                }\n                let box = pixelInBoxes(x, y, boxes);\n                if (box !== null){\n                    // should return a box, move x to box.x + box.width\n                    x += box.width;\n                    continue;\n                }\n                else {\n                    box = exploreSpriteBox(x, y);\n                    boxes.push(box);\n                    x += 1;\n                }\n            }\n            y += 1;\n        }\n        // if that pixel is already in an existing spritebox, move to the right of that box\n        // and continue looking at the rest of the line.\n\n        // if not, make a sprite box containing only that pixel \n        // and expand to fill the dimensions of that sprite\n        return boxes;\n    }\n\n    // makes and returns a box object. This object contains an x value, y value, height and width.\n    function newBox(x, y, width, height){\n        return {x: x, y: y, width: width, height: height};\n    }\n\n    // for each box, check if the pixel's x and y values are inside the dimensions of the box\n    function pixelInBoxes(x, y, boxes){\n        for (let index in boxes){\n            let box = boxes[index];\n            if (x >= box.x && x <= (box.x + box.width)){\n                if (y >= box.y && y <= (box.y + box.height)){\n                    return box;\n                }\n            }\n        }\n        return null;\n    }\n    // explore the pixels around the starting pixel coordinate, until you reach a point where\n    // all edges are that of background color (signaling the borders of the sprite) \n    // or reach the boundaries of the canvas\n    function exploreSpriteBox(x, y){\n        let box = newBox(x, y, 1, 1);\n        let boxBoundaries = boxMeetBoundaries(box);\n        let neighbourCol = neighboursBackCol(box);\n        while (boxCanExpand(boxBoundaries, neighbourCol)){\n            // for each direction, check if the box can expand there\n            // expand the box in that direction, redefine boxMeetBoundaries and neighbourCol\n            // with new box;\n            for (let i=0; i<4; i++) {\n                if (!neighbourCol[i] && !boxBoundaries[i]) {\n                    expandBox(box, i);\n                }\n            }\n            boxBoundaries = boxMeetBoundaries(box);\n            neighbourCol = neighboursBackCol(box);\n        }\n        // need to contract box by 1 in each direction, since it overshoots\n        contractBox(box);\n        return box;\n    }\n\n    // check if the box's edges meet any of the four strict boundaries of the canvas\n    // [left, right, top, bottom]\n    function boxMeetBoundaries(box){\n        return [\n            box.x === 0,\n            box.x + box.width === Canvas.width,\n            box.y === 0,\n            box.y + box.height === Canvas.height,\n        ]\n    }\n\n    // check each neighbouring direction the box can expand to.\n    // if a direction contains any pixel that's not a background color, \n    // you can expand the sprite box in that direction\n    function neighboursBackCol(box){\n        let left = Context.getImageData(box.x-1, box.y, 1, box.height).data;\n        let right = Context.getImageData(box.x + box.width - 1, box.y, 1, box.height).data;\n        let top = Context.getImageData(box.x, box.y-1, box.width, 1).data;\n        let bottom = Context.getImageData(box.x, box.y + box.height - 1, box.width, 1).data;\n\n        return [\n            edgeAllBackgroundCol(left),\n            edgeAllBackgroundCol(right),\n            edgeAllBackgroundCol(top),\n            edgeAllBackgroundCol(bottom)\n        ]\n    }\n\n    function edgeAllBackgroundCol(edge) {\n        // check each pixel. If all of them same col as backgroundCol\n        // return true, otherwise return false\n        for (let i=0; i<edge.length; i+=4){\n            let pixel = [edge[i], edge[i+1], edge[i+2], edge[i+3]];\n            if (!module.pixelsEqual(pixel, backgroundCol)){\n                return false;\n            }\n        }\n        return true;\n    }\n    // a sprite box can expand iff any direction has not reached the canvas boundary\n    // AND that same direction contains a pixel that's not the same color as backgroundColor.\n    function boxCanExpand(edgeColors, edgeBoundaries){\n        for (let i=0; i<4; i++){\n            if (!edgeColors[i] && !edgeBoundaries[i]){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // expand the box in a given direction\n    // 0 = left, 1 = right, 2 = top, 3 = bottom\n    function expandBox(box, direction){\n        switch (direction){\n            case 0:\n               box.x -= 1;\n               box.width += 1;\n               break;\n            case 1:\n               box.width += 1;\n               break;\n            case 2:\n               box.y -= 1;\n               box.height += 1;\n               break;\n            case 3:\n               box.height += 1;\n               break;\n            default:\n               break;\n        }\n\n    }\n\n    // the box overshoots by 1 in each direction, since box constructor has a size = 1\n    // due to index error if set to 0.\n    // this function will contract box to proper boundaries\n    function contractBox(box){\n        if (box.width > 1){\n            box.width -= 1;\n        }\n        if (box.height > 1){\n            box.height -= 1;\n        }\n    }\n\n    return module;\n})();\n\nexport default {spriteFinder};\n","import spriteFinder from './spriteFinder'\nimport { BrowserRouter as Router} from 'react-router-dom';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nvar imageLoader = document.getElementById('imageLoader');\n    imageLoader.addEventListener('change', handleImage, false);\nvar canvas = document.getElementById('imageCanvas');\nvar ctx = canvas.getContext('2d');\nvar scssDisplay = document.getElementById('spriteDisplay');\n\nfunction handleImage(e){\n    let reader = new FileReader();\n    reader.onload = function(event){\n        let img = new Image();\n        img.src = event.target.result;\n        img.onload = function(){\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img,0,0);\n            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n            let data = imageData.data;\n            spriteFinder.setCanvas(canvas, ctx, imageData);\n            // background color is most common color in spriteMap\n            spriteFinder.setBackgroundCol();\n            // find all the boxes in the spritesheet\n            let boxes = spriteFinder.findBoxes();\n\t    let boxJSON = JSON.stringify(boxes);\n            console.log(boxJSON);\n            // for each sprite in spritebox, invert the image.\n            for (let index in boxes){\n            \tlet box = boxes[index];\n            \tlet sprite = ctx.getImageData(box.x, box.y, box.width, box.height)\n            \tlet spriteData = sprite.data;\n            \tfor (let i=0; i<spriteData.length; i+=4){\n            \t\tspriteData[i] = 255 - spriteData[i];\n            \t\tspriteData[i+1] = 255 - spriteData[i+1];\n            \t\tspriteData[i+2] = 255 - spriteData[i+2];\n            \t}\n            \tctx.putImageData(sprite, box.x, box.y);\n            }\n\n            scssDisplay.innerText = makeSCSS(boxes, img.src);\n            // turn each sprite into an scss mixin, write the output to SCSS file.\n        }\n    }\n    reader.readAsDataURL(e.target.files[0]);   \n}\n\n\n// Test function for spriteBox to make sure it's returning the right thing.\nfunction spritefinderTest(){\n\t// canvas 10 * 10\n\tlet sprite1 = {x:1, y:1, width:1, height:1};\n\tlet sprite2 = {x:4, y:4, width:3, height:3};\n\tctx.fillStyle = 'green';\n\tctx.fillRect(sprite1.x, sprite1.y, sprite1.width, sprite1.height);\n\tctx.fillRect(sprite2.x, sprite2.y, sprite2.width, sprite2.height);\n\tlet imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\tlet data = imageData.data;\n\tspriteFinder.setCanvas(canvas, ctx, imageData);\n\tspriteFinder.setBackgroundCol();\n\tlet boxes = spriteFinder.findBoxes();\n}\n\n//spritefinderTest();\n\n// generate scss mixins to represent the images, \n//and a map of all the sprites with their dimensions\nfunction makeSCSS(boxes, url){\n\tlet mixin = \"@mixin image($xpos, $ypos, $width, $height)\" + \n\t\" { \\n\" +\n\t\"height: $height; \\n\" + \n\t\"width: width; \\n\" + \n\t\"background-position: $xpos $ypos; \\n\" + \n\t\"background-repeat: no-repeat; \\n\" + \n    \"};\" + \"\\n\";\n\n\tlet spriteMap = \"$spriteMap: ( \\n\";\n\n\tfor (let boxnum in boxes){\n\t\tlet box = boxes[boxnum];\n        // for xpos and ypos, you must make the initial positions negative due to the way\n        // css fetches sprites on images.\n\t\tlet sprite = \"sprite\" + boxnum + \": (\" + -box.x \n\t\t+ \"px, \" + -box.y + \"px, \" + box.width + \"px, \" + box.height + \"px)\"\n\t\tspriteMap = spriteMap + sprite;\n\t\tif (boxnum !== boxes.length){\n\t\t\tspriteMap = spriteMap + \", \\n\"\n\t\t}\n\t}\n\n\tspriteMap = spriteMap + \"); \\n\";\n\n    return mixin + spriteMap;\n}\n\nReactDOM.render(<Router basename={process.env.PUBLIC_URL}></Router>, document.getElementById('root'));"],"sourceRoot":""}